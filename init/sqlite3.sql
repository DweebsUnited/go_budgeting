DROP TABLE IF EXISTS e_grp;
CREATE TABLE e_grp (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    sort INTEGER NOT NULL DEFAULT (100)
);

DROP TABLE IF EXISTS a;
CREATE TABLE a (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    hidden INTEGER NOT NULL DEFAULT (0),
    offbudget INTEGER NOT NULL DEFAULT (0),
    debt INTEGER NOT NULL DEFAULT (0),
    institution TEXT NOT NULL,
    name TEXT NOT NULL,
    class INTEGER NOT NULL DEFAULT (0)
);

DROP TABLE IF EXISTS e;
CREATE TABLE e (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    groupID INTEGER REFERENCES e_grp(ID) NOT NULL,
    hidden INTEGER NOT NULL DEFAULT (0),
    debtAccount INTEGER REFERENCES a(ID) UNIQUE,
    name TEXT NOT NULL,
    notes TEXT NOT NULL DEFAULT (''),
    goalType INTEGER NOT NULL DEFAULT(0),
    goalAmt INTEGER NOT NULL DEFAULT(0),
    goalTgt INTEGER NOT NULL DEFAULT(0),
    sort INTEGER NOT NULL DEFAULT (999)
);

DROP TABLE IF EXISTS a_t;
CREATE TABLE a_t (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    accountID INTEGER REFERENCES a(ID) NOT NULL,
    type INTEGER NOT NULL DEFAULT (0),
    envelopeID INTEGER REFERENCES e(ID),
    postDate INTEGER NOT NULL,
    amount INTEGER NOT NULL,
    cleared INTEGER NOT NULL DEFAULT (0),
    memo TEXT NOT NULL DEFAULT ('')
);

DROP INDEX IF EXISTS a_t_date;
DROP INDEX IF EXISTS a_t_aid;
DROP INDEX IF EXISTS a_t_eid;
CREATE INDEX a_t_date ON a_t (postDate);
CREATE INDEX a_t_aid ON a_t (accountID);
CREATE INDEX a_t_eid ON a_t (envelopeID);

DROP TRIGGER IF EXISTS a_t_u;
CREATE TRIGGER a_t_u
BEFORE UPDATE
ON a_t
WHEN NEW.accountID != OLD.accountID
BEGIN
    SELECT RAISE (ABORT, 'Changing a_t accountID not supported');
END;

DROP TABLE IF EXISTS e_t;
CREATE TABLE e_t (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    envelopeID INTEGER REFERENCES e(ID) NOT NULL,
    postDate INTEGER NOT NULL,
    amount INTEGER NOT NULL
);

DROP INDEX IF EXISTS e_t_date;
DROP INDEX IF EXISTS e_t_eid;
CREATE INDEX e_t_date ON e_t (postDate);
CREATE INDEX e_t_eid ON e_t (envelopeID);

DROP TRIGGER IF EXISTS e_t_u;
CREATE TRIGGER e_t_u
BEFORE UPDATE
ON e_t
WHEN NEW.envelopeID != OLD.envelopeID
BEGIN
    SELECT RAISE (ABORT, 'Changing e_t envelopeID not supported');
END;

DROP TABLE IF EXISTS a_chk;
CREATE TABLE a_chk (
    accountID INTEGER REFERENCES a(ID) NOT NULL,
    month INTEGER NOT NULL,
    bal INTEGER NOT NULL DEFAULT(0),
    "in" INTEGER NOT NULL DEFAULT(0),
    out INTEGER NOT NULL DEFAULT(0),
    uncleared INTEGER NOT NULL DEFAULT(0),

    PRIMARY KEY(accountID, month)
);

DROP TABLE IF EXISTS e_chk;
CREATE TABLE e_chk (
    envelopeID INTEGER REFERENCES e(ID) NOT NULL,
    month INTEGER NOT NULL,
    bal INTEGER NOT NULL DEFAULT(0),
    "in" INTEGER NOT NULL DEFAULT(0),
    out INTEGER NOT NULL DEFAULT(0),

    PRIMARY KEY(envelopeID, month)
);

DROP TABLE IF EXISTS s_chk;
CREATE TABLE s_chk (
    month INTEGER PRIMARY KEY,
    float INTEGER NOT NULL DEFAULT(0),
    income INTEGER NOT NULL DEFAULT(0),
    expenses INTEGER NOT NULL DEFAULT(0),
    delta INTEGER NOT NULL DEFAULT(0),
    banked INTEGER NOT NULL DEFAULT(0),
    netWorth INTEGER NOT NULL DEFAULT(0)
);

DELETE FROM sqlite_sequence;
INSERT INTO sqlite_sequence (name, seq) VALUES ('a', 0);
INSERT INTO sqlite_sequence (name, seq) VALUES ('a_t', 0);
INSERT INTO sqlite_sequence (name, seq) VALUES ('e_grp', 0);
INSERT INTO sqlite_sequence (name, seq) VALUES ('e', 0);
INSERT INTO sqlite_sequence (name, seq) VALUES ('e_t', 0);

-- Initial summary
INSERT INTO s_chk (month) VALUES (0);

-- Default Envelope Groups
INSERT INTO e_grp (name,sort) VALUES ('Misc', 999);